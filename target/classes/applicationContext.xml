<?xml version="1.0" encoding="UTF-8"?>
<!-- <bean>저장소에 해당하는 xml설정 파일을 참조하여 bean의 생명주기를 관리하고 여러가지 서비스를 제공 중요함!! -->

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:cache="http://www.springframework.org/schema/cache"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jee="http://www.springframework.org/schema/jee"
	xmlns:lang="http://www.springframework.org/schema/lang"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:util="http://www.springframework.org/schema/util"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.2.xsd
		http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.2.xsd
		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.2.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd
		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-4.2.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd">

	<!-- <import>태그 스프링 기반의 애플리케이션을 단순한 bean등록 외에도 트래젝션 관리,예외처리,다국어 처리 등 복잡하고 
		다양한 설정이 필요 이런 모든 설정을 하나의 파일로 모두 처리할 수도 있지만 그렇게 하면 스프링 설정파일이 너무 길어지고 관리도 어려움 
		결국 기능별 여러 xml파일로 나누어 설정하는 것이 더 효율적인데 이렇게 분리하여 작성한 설정파일을 하나로 통합할 때 import앨리먼트 
		사용 import태그를 이용하여 어려 스프링 설정파일을 포함하므로 한 파일에 작성하는 것과 같은 효과를 낼 수 있다 예를 들명 <import 
		resource="Context-datasource.xml"> <import resource="Context-transaction.xml"> -->

	<!-- init-method속성 <bean>등록된 클래스 객체를 생성한 후에 init-method로 지정된 메서드를 호출함, 이 
		메서드에서 멤버변수의 댛산 초기화 작업을 처리함 -->

	<!--destroy-method속성 스프링 컨테이너가 객체를 삭제하기 직전에 호출될 임의의 메서드를 지정 -->

	<!-- lazy-init속성 true로 하면 미리생성하지 않고 클라이언트가 요청하는 시점에 생성,그러므로 메모리관리에 효율적이다 -->

	<!-- scope속성 기본이 singleton, 생략됨,singleton은단하나만 생성되어 운용되도록 한다. prototype은 
		요청될 때 마다 새로운 객체생성 -->


	<!--id는 생략 가능,name도 있으나 id사용을 선호함 , 클래스는 정확한 패키지 경로와 클래스 이름을 지정,자동완성 기능 
		활용 -->
	<!-- <bean id="tv" class="SamsungTV" init-method="initMethod" destroy-method="destoryMethod" 
		scope="prototype"></bean> -->

	<!-- polymorphism패키지에있는 클래스들 사용 -->
	<!-- constructor-arg ref="sony">이기때문에 id가 sony인 class먼저 생성되기때문에 출력하면 sony관련 
		내용이 먼저 출력되는 것이다 -->

	<!-- <bean id="stv" class="polymorphism.SamsungTV" scope="singleton"> -->
	<!--아래는 생성자를 이용한 의존성 처리 -->
	<!-- <constructor-arg ref="apple"></constructor-arg> <constructor-arg value="50"></constructor-arg> -->

	<!--아래는 setter인젝션 이용한 의존성 처리 -->
	<!--ref의 값을 bean id와 맞춰줘야한다 -->
	<!-- <property name="speaker" ref="sony"></property> <property name="price" 
		value="1000"></property> -->
	<!-- </bean> -->


	<!-- <bean id="sony" class="polymorphism.SonySpeaker" ></bean> -->
	<!-- AppleSpeaker클래스를 만들고 id apple을 만들어 위에 ref를 apple로 변경해주면 apple에 관련된 
		내용만 출력 -->
	<!-- <bean id="apple" class="polymorphism.AppleSpeaker" ></bean> -->
	<!-- <bean id="sony" class="polymorphism.SonySpeaker" ></bean> -->


	<!-- <bean id="collectionBean" class="injection.CollectionBean"> <property 
		name="addressList"> -->

	<!-- <list> <value>모란역</value> <value>강남역</value> </list> -->

	<!-- Map<String,String>타입일 때 Map컬렉션을 썼을때 -->

	<!-- <map> <entry> <key><value>이름1</value></key> <value>홍일동</value> </entry> 
		<entry> <key><value>이름2</value></key> <value>홍이동</value> </entry> </map> -->

	<!-- props컬렉션을 썻을때 -->
	<!-- <props> <prop key="고길동">모란역</prop> <prop key="조아름">서울역</prop> </props> 
		</property> -->

	<!-- </bean> -->

<!-- dateSource설정 : 스프링 JDBC만을 위한 설정은 아니고 후에 테스트와 트래잭션 처리나 mybatis연동, jpa연동에서도 중요
일반적으로 org.apache.commons.dbcp.BasicDataSource를 많이 사용한다-->

<context:property-placeholder location="classpath:config/database.properties"/>
	<bean id="dataSource"
		class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driver}"></property>
		<property name="url" value="${jdbc.url}"></property>
		<property name="username" value="${jdbc.username}"></property>
		<property name="password" value="${jdbc.password}"></property>
	</bean>
	
	<!-- spring jdbc설정 -->
	<bean class="org.springframework.jdbc.core.JdbcTemplate">
	<property name="dataSource" ref="dataSource"></property>
	</bean>

<!-- Transaction 설정 -->
<!-- 모든 트랜잭션 관리자는 platformTransactionManager 인터페이스를 구현한 클래스이다
데이타소스트랜잭션매니저도 다른 트랜잭션 관리자와 마찬가지로 platformTransactionManager의 commit,rollback메서드를 재정의하여
구현하고 있을 뿐이지 platformTransactionManager객체 스스로 자신이 가진 메서드를 실행할 수는 없다
그렇다면 트랜잭션 관리자가 가지고 있는 메소드를 호출하면서 실질적인 크랜잭션 관리 기능을 제공하는 것은 무엇일까 이 시점에서
머드바이스의 개념을 다시 한 번 떠올려 보기 바란다 어드바이스는 비지니스 메서드 실행 전이나 후에 동작하여 비지니스 메소드와 무관하게
공통기능능 제공한다 이 공통 기능 중에서 가장 대표적인 것이 예외처리와 트랜잭션 처리다
비즈니스 메서드가 실행되다가 예외가 발생하면 해당 메서드에 대한 트랜잭션을 롤백하고 문제없이 정상으로 수행 종료되면 트랜잭션을 커밋하면 된다
트랜잭션을 커밋 롤백하기 위한 객체즞 데이타소스트랜잭션매니저 로 등록했다 이 트랜잭션 관리자를 이용하여 트랜잭션을 제어하는 어드바이스를 등록하면 된다
 -->
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>

<!--get으로 시작하는 모든 메소드는 읽기 전용으로 처리되어 트랜잭션 관리대상에서 제외하고 나머지 메소드들은 트랜잭션 관리에 포함  -->
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true"/>
			<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
	
	<aop:config>
		<aop:pointcut id="txPointcut"  expression="execution(* com.springbook.biz..*(..))"/>
		<aop:advisor pointcut-ref="txPointcut" advice-ref="txAdvice"/>
	</aop:config>

	<!-- Bean을 등록하지 않고 자동으로 생성하기 위함 , 이 설정을 추가하면 스프링 ㅈ컨테이너는 클래스 패스에 있는 클래스들을 
		스캔하여 @Component가 설정된 -->
	<context:component-scan
		base-package="com.springbook.biz" />
		
		<!-- AOP관련 어노테이션들을 인식하고 용도에 맞게 처리해 줌 -->
		<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

	<!-- AOP -->
	<!--  <bean id="around" class="com.springbook.biz.common.AroundAdvice"></bean> -->
	
 <!-- <bean id="log" class="com.springbook.biz.common.LogAdvice"></bean>  -->
	<!--  <aop:config> -->
		<!-- 어드바이스를 조종할 위치 선정하는 설정,어드바이스(보조기능)는 포인트 컷으로 적용됳 위치가 결정되고, 그 시점에 어드바이스가 
			실행된다 포인트 컷은 포인트컷 표현식을 사용하여 설정할 수 있으며 특정 어노테이션을 지정하여 설정할 수도 있다. -->
			<!--  (*   com.springbook.biz..*Impl.*(..)) -->
			<!-- 리턴타입  패키지경로                          ..클래스명.메소드명 및 매개변수 -->
	<!-- 	<aop:pointcut
			expression="execution(* com.springbook.biz..*Impl.*(..))"
			id="allPointCut" /> -->
			
		<!-- 	<aop:pointcut
			expression="execution(* com.springbook.biz..*Impl.get*(..))"
			id="getPointCut" /> -->
	<!-- 		
		<aop:aspect ref="log">
			<aop:before pointcut-ref="allPointCut" method="printLog" />
		</aop:aspect> -->
	
		<!-- aop:advisor
		엘리먼트는 포인트컷과 어드바이스를 결합한다는 점에서는 에스펙트와 같은 기능을 한다
		하지만 트래젝션 설정 같은 몇몇 특수한 애스펙트가 아닌 어드바이저를 사용해야 한다 왜냐하면 어드바이스 객체의 메소드 이름을
		확인할 수 없을 때 
		 -->
		
	<!-- </aop:config>    -->

</beans>
